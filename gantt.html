<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gantt Chart Tool with Resource Filter</title>
    <style>
        /* Ensure the box model includes padding and borders in the element's total size */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
        }

        #controls {
            margin: 10px;
        }

        #controls button {
            margin-right: 5px;
        }

        #controls select {
            margin-right: 5px;
        }

        #ganttChartContainer {
            width: 100%;
            /* Adjust the height to account for the header and controls */
            height: calc(100vh - 130px); /* Adjust this value if necessary */
            overflow: auto; /* Enable both horizontal and vertical scrolling */
            position: relative;
        }

        svg {
            font-family: Arial, sans-serif;
        }

        .task-name {
            fill: #000;
            font-size: 12px;
            text-anchor: start;
        }

        .task-bar {
            cursor: pointer;
        }

        .axis-label {
            fill: #333;
            font-size: 12px;
            text-anchor: middle;
        }

        .axis-line {
            stroke: #e0e0e0;
            stroke-width: 1;
        }

        .header {
            fill: #f0f0f0;
            stroke: #ccc;
            stroke-width: 1;
        }

        .header-text {
            fill: #000;
            font-size: 12px;
            font-weight: bold;
            text-anchor: start;
        }

        /* Customize scrollbar for WebKit-based browsers (Chrome, Edge, Safari) */
        #ganttChartContainer::-webkit-scrollbar {
            height: 16px; /* Increase the scrollbar height */
        }

        #ganttChartContainer::-webkit-scrollbar-thumb {
            background-color: #ccc;
            border-radius: 8px;
        }

        /* Optional: For Firefox, use scrollbar-width and scrollbar-color */
        #ganttChartContainer {
            scrollbar-width: thin;
            scrollbar-color: #ccc transparent;
        }

        /* Cursor style for the draggable separator */
        .separator-line {
            cursor: col-resize;
        }

        /* Style for dependency lines */
        .dependency-line {
            stroke: #555;
            stroke-width: 1.5;
            fill: none;
            marker-end: url(#arrowhead);
        }

        /* Tooltip styling */
        #tooltip {
            position: absolute;
            pointer-events: none;
            background-color: rgba(50, 50, 50, 0.9);
            color: #fff;
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>Gantt Chart Tool with Resource Filter</h1>
    <div id="controls">
        <input type="file" id="csvFileInput" accept=".csv" />
        <button id="zoomInButton">Zoom In</button>
        <button id="zoomOutButton">Zoom Out</button>
        <select id="resourceFilter">
            <!-- Options will be populated dynamically -->
        </select>
    </div>
    <div id="ganttChartContainer">
        <!-- Gantt chart will be rendered here -->
    </div>

    <!-- Tooltip for displaying Resource Names and Notes -->
    <div id="tooltip"></div>

    <script>
        document.getElementById('csvFileInput').addEventListener('change', function(e) {
            var file = e.target.files[0];
            if (!file) {
                return;
            }
            var reader = new FileReader();
            reader.onload = function(e) {
                var contents = e.target.result;
                parseCSV(contents);
            };
            reader.readAsText(file);
        });

        var tasks = [];
        var zoomLevel = 1;
        var taskNameColumnWidth = 200; // Initial width
        var isResizing = false;
        var startX = 0;
        var filteredTasks = [];
        var allResources = [];
        var resourceFilter = 'All';

        function parseCSV(contents) {
            var lines = contents.trim().split('\n');
            var delimiter = contents.indexOf('\t') !== -1 ? '\t' : ','; // Detect delimiter
            var headers = parseCSVLine(lines[0], delimiter);

            // Normalize headers: remove spaces and make consistent property names
            headers = headers.map(function(header) {
                return header.trim().replace(/\s+/g, '');
            });

            tasks = [];

            for (var i = 1; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line === '') {
                    continue;
                }

                var values = parseCSVLine(line, delimiter);

                // Ensure values array has exactly as many elements as headers
                if (values.length > headers.length) {
                    // Combine extra values into the last field
                    values[headers.length - 1] = values.slice(headers.length - 1).join(delimiter);
                    values = values.slice(0, headers.length);
                } else {
                    while (values.length < headers.length) {
                        values.push('');
                    }
                }

                // Remove quotes from values, if any
                values = values.map(function(v) {
                    return v.replace(/^"|"$/g, '').trim();
                });

                var task = {};
                for (var j = 0; j < headers.length; j++) {
                    var header = headers[j];
                    var value = values[j];
                    task[header] = value;
                }

                tasks.push(task);
            }

            // Populate the resource filter dropdown
            populateResourceFilter();

            renderGanttChart();
        }

        function parseCSVLine(line, delimiter) {
            var values = [];
            var current = '';
            var insideQuotes = false;
            for (var i = 0; i < line.length; i++) {
                var char = line[i];
                if (char === '"') {
                    insideQuotes = !insideQuotes;
                } else if (char === delimiter && !insideQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current);
            return values;
        }

        function populateResourceFilter() {
            var resourceSet = new Set();
            tasks.forEach(function(task) {
                if (task.ResourceNames && task.ResourceNames.trim() !== '') {
                    resourceSet.add(task.ResourceNames.trim());
                }
            });

            allResources = Array.from(resourceSet).sort();
            allResources.unshift('All'); // Add 'All' at the beginning

            var resourceFilterSelect = document.getElementById('resourceFilter');
            resourceFilterSelect.innerHTML = ''; // Clear previous options

            allResources.forEach(function(resource) {
                var option = document.createElement('option');
                option.value = resource;
                option.textContent = resource;
                resourceFilterSelect.appendChild(option);
            });

            resourceFilterSelect.value = resourceFilter; // Set the current filter
            resourceFilterSelect.addEventListener('change', function() {
                resourceFilter = this.value;
                renderGanttChart();
            });
        }

        function filterTasks() {
            if (resourceFilter === 'All') {
                filteredTasks = tasks.slice(); // Copy all tasks
                return;
            }

            // Filter tasks by resource
            var tasksWithResource = tasks.filter(function(task) {
                return task.ResourceNames && task.ResourceNames.trim() === resourceFilter;
            });

            // Collect IDs of tasks with the selected resource
            var taskIDsWithResource = tasksWithResource.map(function(task) {
                return task.ID;
            });

            // Include predecessor tasks
            var includedTaskIDs = new Set(taskIDsWithResource);
            tasksWithResource.forEach(function(task) {
                if (task.Predecessors) {
                    var predecessors = task.Predecessors.split(',');
                    predecessors.forEach(function(predecessorStr) {
                        var match = predecessorStr.trim().match(/^(\d+)/);
                        if (match) {
                            var predecessorID = match[1];
                            includedTaskIDs.add(predecessorID);
                        }
                    });
                }
            });

            // Collect all tasks that should be included
            filteredTasks = tasks.filter(function(task) {
                return includedTaskIDs.has(task.ID);
            });
        }

        function renderGanttChart() {
            var ganttChartContainer = document.getElementById('ganttChartContainer');
            ganttChartContainer.innerHTML = ''; // Clear previous chart

            // Filter tasks based on selected resource
            filterTasks();

            // Calculate date range
            var minDate = null;
            var maxDate = null;

            filteredTasks.forEach(function(task) {
                var startDate = new Date(task.Start);
                var finishDate = new Date(task.Finish);

                if (isNaN(startDate.getTime())) {
                    console.error('Invalid start date for task:', task);
                    return; // Skip this task
                }
                if (isNaN(finishDate.getTime())) {
                    console.error('Invalid finish date for task:', task);
                    return; // Skip this task
                }

                if (!minDate || startDate < minDate) {
                    minDate = startDate;
                }
                if (!maxDate || finishDate > maxDate) {
                    maxDate = finishDate;
                }
            });

            if (!minDate || !maxDate) {
                // No valid tasks to display
                return;
            }

            // Add buffer before and after the date range
            var bufferDuration = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
            minDate = new Date(minDate.getTime() - bufferDuration);
            maxDate = new Date(maxDate.getTime() + bufferDuration);

            var containerWidth = ganttChartContainer.offsetWidth;
            var chartWidth = (containerWidth - taskNameColumnWidth) * zoomLevel;
            var taskRowHeight = 30;
            var headerHeight = 30;
            var totalHeight = filteredTasks.length * taskRowHeight + headerHeight;

            // Create SVG element
            var svgNS = 'http://www.w3.org/2000/svg';
            var svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('height', totalHeight);
            ganttChartContainer.appendChild(svg);

            // Define markers for dependency lines
            var defs = document.createElementNS(svgNS, 'defs');
            svg.appendChild(defs);

            var marker = document.createElementNS(svgNS, 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '0');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            marker.setAttribute('markerUnits', 'strokeWidth');

            var markerPath = document.createElementNS(svgNS, 'path');
            markerPath.setAttribute('d', 'M0,0 L0,7 L10,3.5 z');
            markerPath.setAttribute('fill', '#555');
            marker.appendChild(markerPath);
            defs.appendChild(marker);

            // Define clipPath for task names
            var clipPath = document.createElementNS(svgNS, 'clipPath');
            clipPath.setAttribute('id', 'taskNameClip');
            defs.appendChild(clipPath);

            var clipRect = document.createElementNS(svgNS, 'rect');
            clipRect.setAttribute('x', 0);
            clipRect.setAttribute('y', headerHeight);
            clipRect.setAttribute('width', taskNameColumnWidth - 5); // Subtract some padding
            clipRect.setAttribute('height', totalHeight - headerHeight);
            clipPath.appendChild(clipRect);

            // Draw header background
            var headerRect = document.createElementNS(svgNS, 'rect');
            headerRect.setAttribute('x', 0);
            headerRect.setAttribute('y', 0);
            headerRect.setAttribute('width', taskNameColumnWidth + chartWidth);
            headerRect.setAttribute('height', headerHeight);
            headerRect.setAttribute('class', 'header');
            svg.appendChild(headerRect);

            // Draw "Task Name" header
            var taskNameHeader = document.createElementNS(svgNS, 'text');
            taskNameHeader.setAttribute('x', 5);
            taskNameHeader.setAttribute('y', headerHeight / 2 + 5);
            taskNameHeader.setAttribute('class', 'header-text');
            taskNameHeader.textContent = 'Task Name';
            svg.appendChild(taskNameHeader);

            // Draw x-axis labels and grid lines
            drawXAxis(svg, minDate, maxDate, chartWidth, headerHeight, totalHeight, taskNameColumnWidth);

            // Map task IDs to their positions and data
            var taskMap = {};
            var validTaskIndex = 0; // Index for tasks with valid dates
            filteredTasks.forEach(function(task, index) {
                var startDate = new Date(task.Start);
                var finishDate = new Date(task.Finish);

                if (isNaN(startDate.getTime()) || isNaN(finishDate.getTime())) {
                    // Skip tasks with invalid dates
                    return;
                }

                var taskStartOffset = ((startDate - minDate) / (maxDate - minDate)) * chartWidth;
                var taskDuration = ((finishDate - startDate) / (maxDate - minDate)) * chartWidth;

                var yPosition = headerHeight + validTaskIndex * taskRowHeight;

                // Store task position data
                taskMap[task.ID] = {
                    x: taskNameColumnWidth + taskStartOffset,
                    y: yPosition,
                    width: taskDuration,
                    height: taskRowHeight - 10, // Vertical padding
                    index: validTaskIndex
                };

                // Draw task name background (optional)
                var taskNameBg = document.createElementNS(svgNS, 'rect');
                taskNameBg.setAttribute('x', 0);
                taskNameBg.setAttribute('y', yPosition);
                taskNameBg.setAttribute('width', taskNameColumnWidth);
                taskNameBg.setAttribute('height', taskRowHeight);
                taskNameBg.setAttribute('fill', '#fff');
                taskNameBg.setAttribute('stroke', '#e0e0e0');
                svg.appendChild(taskNameBg);

                // Draw task name
                var taskNameText = document.createElementNS(svgNS, 'text');
                taskNameText.setAttribute('x', 5);
                taskNameText.setAttribute('y', yPosition + taskRowHeight / 2 + 4); // Vertically center text
                taskNameText.setAttribute('class', 'task-name');
                taskNameText.setAttribute('clip-path', 'url(#taskNameClip)');
                taskNameText.textContent = task.Name || 'No Name';

                // Indent task names based on OutlineLevel
                var outlineLevel = parseInt(task.OutlineLevel) || 1;
                taskNameText.setAttribute('dx', (outlineLevel - 1) * 15);

                // Add tooltip to task name (optional)
                var title = document.createElementNS(svgNS, 'title');
                title.textContent = task.Name || 'No Name';
                taskNameText.appendChild(title);

                svg.appendChild(taskNameText);

                // Determine task bar color based on OutlineLevel
                var taskColor = '#3498db'; // Default blue color
                if (outlineLevel === 1) {
                    taskColor = '#7f8c8d'; // Grey for Outline Level 1
                } else if (outlineLevel === 2) {
                    taskColor = '#3498db'; // Current blue for Outline Level 2
                } else if (outlineLevel >= 3) {
                    taskColor = '#85c1e9'; // Lighter blue for Outline Level 3 and above
                }

                // Draw task bar
                var rect = document.createElementNS(svgNS, 'rect');
                rect.setAttribute('x', taskNameColumnWidth + taskStartOffset); // Offset by task name column width
                rect.setAttribute('y', yPosition + 5); // Slight vertical padding
                rect.setAttribute('width', taskDuration);
                rect.setAttribute('height', taskRowHeight - 10); // Vertical padding
                rect.setAttribute('fill', taskColor);
                rect.setAttribute('class', 'task-bar');
                rect.setAttribute('data-index', index);

                // Add event listeners for tooltip
                rect.addEventListener('mouseover', function(e) {
                    showTooltip(e, task);
                });
                rect.addEventListener('mousemove', function(e) {
                    moveTooltip(e);
                });
                rect.addEventListener('mouseout', function(e) {
                    hideTooltip();
                });

                svg.appendChild(rect);

                validTaskIndex++; // Increment only for valid tasks
            });

            // Draw dependency lines
            drawDependencies(svg, filteredTasks, taskMap, taskNameColumnWidth);

            // Adjust SVG width to accommodate content
            var requiredWidth = taskNameColumnWidth + chartWidth; // Total width
            svg.setAttribute('width', requiredWidth);

            // Set up zoom controls
            document.getElementById('zoomInButton').onclick = function() {
                zoomLevel *= 1.5;
                renderGanttChart();
            };

            document.getElementById('zoomOutButton').onclick = function() {
                zoomLevel /= 1.5;
                renderGanttChart();
            };

            // Draw separator line and make it draggable
            drawSeparatorLine(svg, headerHeight, totalHeight);
        }

        function drawXAxis(svg, minDate, maxDate, chartWidth, headerHeight, totalHeight, taskNameColumnWidth) {
            var svgNS = 'http://www.w3.org/2000/svg';

            // Determine time scale based on zoom level
            var timeSpan = maxDate - minDate;
            var pixelsPerDay = chartWidth / (timeSpan / (1000 * 3600 * 24));

            var labelInterval; // in milliseconds
            var dateFormatOptions;

            if (pixelsPerDay * zoomLevel > 80) {
                // Show days
                labelInterval = 1000 * 3600 * 24; // One day
                dateFormatOptions = { day: 'numeric', month: 'short' };
            } else if (pixelsPerDay * zoomLevel > 20) {
                // Show weeks
                labelInterval = 1000 * 3600 * 24 * 7; // One week
                dateFormatOptions = { day: 'numeric', month: 'short' };
            } else {
                // Show months
                labelInterval = 1000 * 3600 * 24 * 30; // Approximate one month
                dateFormatOptions = { month: 'short', year: 'numeric' };
            }

            // Draw labels and grid lines
            for (var time = minDate.getTime(); time <= maxDate.getTime(); time += labelInterval) {
                var xPos = taskNameColumnWidth + ((time - minDate.getTime()) / (maxDate - minDate)) * chartWidth;

                // Grid line
                var line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', xPos);
                line.setAttribute('y1', headerHeight);
                line.setAttribute('x2', xPos);
                line.setAttribute('y2', totalHeight);
                line.setAttribute('class', 'axis-line');
                svg.appendChild(line);

                // Label
                if (xPos > taskNameColumnWidth + 30) { // Ensure labels don't overlap with Task Name column
                    var label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', xPos);
                    label.setAttribute('y', headerHeight / 2 + 5);
                    label.setAttribute('class', 'axis-label');
                    label.textContent = new Date(time).toLocaleDateString('en-US', dateFormatOptions);
                    svg.appendChild(label);
                }
            }

            // Draw vertical line separating task names and chart
            // This line will be draggable
            var separatorLine = document.createElementNS(svgNS, 'line');
            separatorLine.setAttribute('x1', taskNameColumnWidth);
            separatorLine.setAttribute('y1', 0);
            separatorLine.setAttribute('x2', taskNameColumnWidth);
            separatorLine.setAttribute('y2', totalHeight);
            separatorLine.setAttribute('stroke', '#ccc');
            separatorLine.setAttribute('stroke-width', '3');
            separatorLine.setAttribute('class', 'separator-line');
            separatorLine.style.cursor = 'col-resize';
            svg.appendChild(separatorLine);

            // Event listeners for resizing
            separatorLine.addEventListener('mousedown', startResizing);
            svg.addEventListener('mousemove', resizing);
            svg.addEventListener('mouseup', stopResizing);
            svg.addEventListener('mouseleave', stopResizing);
        }

        function drawDependencies(svg, tasks, taskMap, taskNameColumnWidth) {
            var svgNS = 'http://www.w3.org/2000/svg';

            tasks.forEach(function(task) {
                if (!task.Predecessors || !taskMap[task.ID]) {
                    return; // Skip if no predecessors or task not mapped
                }

                var predecessors = task.Predecessors.split(',');

                predecessors.forEach(function(predecessorStr) {
                    var match = predecessorStr.trim().match(/^(\d+)(FS|SS|FF|SF)?$/i);
                    if (!match) return;

                    var predecessorID = match[1];
                    var dependencyType = match[2] || 'FS'; // Default to Finish-to-Start

                    var predecessorTask = taskMap[predecessorID];
                    var successorTask = taskMap[task.ID];

                    if (!predecessorTask || !successorTask) return;

                    // Calculate positions based on dependency type
                    var startX, startY, endX, endY;

                    // Adjust positions for arrow drawing
                    var gap = 5; // Gap between task bars and dependency lines

                    if (dependencyType.toUpperCase() === 'FS') {
                        // Finish-to-Start
                        startX = predecessorTask.x + predecessorTask.width;
                        startY = predecessorTask.y + predecessorTask.height / 2 + 5;
                        endX = successorTask.x;
                        endY = successorTask.y + successorTask.height / 2 + 5;
                    } else if (dependencyType.toUpperCase() === 'SS') {
                        // Start-to-Start
                        startX = predecessorTask.x;
                        startY = predecessorTask.y + predecessorTask.height / 2 + 5;
                        endX = successorTask.x;
                        endY = successorTask.y + successorTask.height / 2 + 5;
                    } else if (dependencyType.toUpperCase() === 'FF') {
                        // Finish-to-Finish
                        startX = predecessorTask.x + predecessorTask.width;
                        startY = predecessorTask.y + predecessorTask.height / 2 + 5;
                        endX = successorTask.x + successorTask.width;
                        endY = successorTask.y + successorTask.height / 2 + 5;
                    } else if (dependencyType.toUpperCase() === 'SF') {
                        // Start-to-Finish
                        startX = predecessorTask.x;
                        startY = predecessorTask.y + predecessorTask.height / 2 + 5;
                        endX = successorTask.x + successorTask.width;
                        endY = successorTask.y + successorTask.height / 2 + 5;
                    } else {
                        // Unknown dependency type
                        return;
                    }

                    // Draw the dependency line
                    var path = document.createElementNS(svgNS, 'path');
                    path.setAttribute('class', 'dependency-line');

                    // Create a path that goes from the start point to the end point with right angles
                    var d = [
                        'M', startX, startY,
                        'L', startX + gap, startY,
                        'L', startX + gap, endY,
                        'L', endX - gap, endY,
                        'L', endX, endY
                    ].join(' ');

                    path.setAttribute('d', d);

                    svg.appendChild(path);
                });
            });
        }

        function drawSeparatorLine(svg, headerHeight, totalHeight) {
            // The separator line is already drawn in drawXAxis and event listeners are attached there
            // This function is kept for compatibility
        }

        function startResizing(e) {
            isResizing = true;
            startX = e.clientX;
            e.preventDefault();
        }

        function resizing(e) {
            if (!isResizing) return;
            var dx = e.clientX - startX;
            startX = e.clientX;
            taskNameColumnWidth += dx;
            if (taskNameColumnWidth < 100) taskNameColumnWidth = 100; // Minimum width
            if (taskNameColumnWidth > 500) taskNameColumnWidth = 500; // Maximum width
            renderGanttChart();
        }

        function stopResizing(e) {
            isResizing = false;
        }

        // Tooltip functions
        var tooltip = document.getElementById('tooltip');

        function showTooltip(e, task) {
            var resource = task.ResourceNames || 'No Resource';
            var notes = task.Notes || '';

            // Strip HTML tags from notes
            notes = stripHTMLTags(notes);

            var content = '';
            if (resource) {
                content += '<strong>Resource:</strong> ' + resource + '<br>';
            }
            if (notes) {
                content += '<strong>Notes:</strong><br>' + notes;
            }

            tooltip.innerHTML = content;
            tooltip.style.display = 'block';
            moveTooltip(e);
        }

        function moveTooltip(e) {
            var ganttChartContainer = document.getElementById('ganttChartContainer');
            var rect = ganttChartContainer.getBoundingClientRect();
            var x = e.clientX - rect.left + ganttChartContainer.scrollLeft + 10; // Offset to prevent cursor overlap
            var y = e.clientY - rect.top + ganttChartContainer.scrollTop + 10;
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        function stripHTMLTags(html) {
            // Replace <br> and <br/> with newline
            html = html.replace(/<br\s*\/?>/gi, '\n');

            // Remove all other HTML tags
            var tmp = document.createElement('div');
            tmp.innerHTML = html;
            var text = tmp.textContent || tmp.innerText || '';

            return text.trim();
        }
    </script>
</body>
</html>
